<?php
/**
 * ChatsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Vendor\Waha\Generated
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * WAHA - WhatsApp HTTP API
 *
 * <b>WhatsApp HTTP API</b> that you can run in a click!<br/><a href=\"/dashboard\"><b>ðŸ“Š Dashboard</b></a><br/><br/>Learn more:<ul><li><a href=\"https://waha.devlike.pro/\" target=\"_blank\">Documentation</a></li><li><a href=\"https://waha.devlike.pro/docs/how-to/engines/#features\" target=\"_blank\">Supported features in engines</a></li><li><a href=\"https://github.com/devlikeapro/waha\" target=\"_blank\">GitHub - WAHA Core</a></li><li><a href=\"https://github.com/devlikeapro/waha-plus\" target=\"_blank\">GitHub - WAHA Plus</a></li></ul><p>Support the project and get WAHA Plus version!</p><ul><li><a href=\"https://waha.devlike.pro/docs/how-to/plus-version/\" target=\"_blank\">WAHA Plus</a></li><li><a href=\"https://patreon.com/wa_http_api/\" target=\"_blank\">Patreon</a></li><li><a href=\"https://boosty.to/wa-http-api/\" target=\"_blank\">Boosty</a></li><li><a href=\"https://portal.devlike.pro/\" target=\"_blank\">Patron Portal</a></li></ul>
 *
 * The version of the OpenAPI document: 2026.2.2
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Vendor\Waha\Generated\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Vendor\Waha\Generated\ApiException;
use Vendor\Waha\Generated\Configuration;
use Vendor\Waha\Generated\HeaderSelector;
use Vendor\Waha\Generated\ObjectSerializer;

/**
 * ChatsApi Class Doc Comment
 *
 * @category Class
 * @package  Vendor\Waha\Generated
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ChatsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'chatsControllerArchiveChat' => [
            'application/json',
        ],
        'chatsControllerClearMessages' => [
            'application/json',
        ],
        'chatsControllerDeleteChat' => [
            'application/json',
        ],
        'chatsControllerDeleteMessage' => [
            'application/json',
        ],
        'chatsControllerEditMessage' => [
            'application/json',
        ],
        'chatsControllerGetChatMessage' => [
            'application/json',
        ],
        'chatsControllerGetChatMessages' => [
            'application/json',
        ],
        'chatsControllerGetChatPicture' => [
            'application/json',
        ],
        'chatsControllerGetChats' => [
            'application/json',
        ],
        'chatsControllerGetChatsOverview' => [
            'application/json',
        ],
        'chatsControllerPinMessage' => [
            'application/json',
        ],
        'chatsControllerPostChatsOverview' => [
            'application/json',
        ],
        'chatsControllerReadChatMessages' => [
            'application/json',
        ],
        'chatsControllerUnarchiveChat' => [
            'application/json',
        ],
        'chatsControllerUnpinMessage' => [
            'application/json',
        ],
        'chatsControllerUnreadChat' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation chatsControllerArchiveChat
     *
     * Archive the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerArchiveChat'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function chatsControllerArchiveChat($session, $chat_id, string $contentType = self::contentTypes['chatsControllerArchiveChat'][0])
    {
        list($response) = $this->chatsControllerArchiveChatWithHttpInfo($session, $chat_id, $contentType);
        return $response;
    }

    /**
     * Operation chatsControllerArchiveChatWithHttpInfo
     *
     * Archive the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerArchiveChat'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerArchiveChatWithHttpInfo($session, $chat_id, string $contentType = self::contentTypes['chatsControllerArchiveChat'][0])
    {
        $request = $this->chatsControllerArchiveChatRequest($session, $chat_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerArchiveChatAsync
     *
     * Archive the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerArchiveChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerArchiveChatAsync($session, $chat_id, string $contentType = self::contentTypes['chatsControllerArchiveChat'][0])
    {
        return $this->chatsControllerArchiveChatAsyncWithHttpInfo($session, $chat_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerArchiveChatAsyncWithHttpInfo
     *
     * Archive the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerArchiveChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerArchiveChatAsyncWithHttpInfo($session, $chat_id, string $contentType = self::contentTypes['chatsControllerArchiveChat'][0])
    {
        $returnType = 'object';
        $request = $this->chatsControllerArchiveChatRequest($session, $chat_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerArchiveChat'
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerArchiveChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerArchiveChatRequest($session, $chat_id, string $contentType = self::contentTypes['chatsControllerArchiveChat'][0])
    {

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerArchiveChat'
            );
        }

        // verify the required parameter 'chat_id' is set
        if ($chat_id === null || (is_array($chat_id) && count($chat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chat_id when calling chatsControllerArchiveChat'
            );
        }


        $resourcePath = '/api/{session}/chats/{chatId}/archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }
        // path params
        if ($chat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chatId' . '}',
                ObjectSerializer::toPathValue($chat_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chatsControllerClearMessages
     *
     * Clears all messages from the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerClearMessages'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function chatsControllerClearMessages($session, $chat_id, string $contentType = self::contentTypes['chatsControllerClearMessages'][0])
    {
        $this->chatsControllerClearMessagesWithHttpInfo($session, $chat_id, $contentType);
    }

    /**
     * Operation chatsControllerClearMessagesWithHttpInfo
     *
     * Clears all messages from the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerClearMessages'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerClearMessagesWithHttpInfo($session, $chat_id, string $contentType = self::contentTypes['chatsControllerClearMessages'][0])
    {
        $request = $this->chatsControllerClearMessagesRequest($session, $chat_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerClearMessagesAsync
     *
     * Clears all messages from the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerClearMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerClearMessagesAsync($session, $chat_id, string $contentType = self::contentTypes['chatsControllerClearMessages'][0])
    {
        return $this->chatsControllerClearMessagesAsyncWithHttpInfo($session, $chat_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerClearMessagesAsyncWithHttpInfo
     *
     * Clears all messages from the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerClearMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerClearMessagesAsyncWithHttpInfo($session, $chat_id, string $contentType = self::contentTypes['chatsControllerClearMessages'][0])
    {
        $returnType = '';
        $request = $this->chatsControllerClearMessagesRequest($session, $chat_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerClearMessages'
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerClearMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerClearMessagesRequest($session, $chat_id, string $contentType = self::contentTypes['chatsControllerClearMessages'][0])
    {

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerClearMessages'
            );
        }

        // verify the required parameter 'chat_id' is set
        if ($chat_id === null || (is_array($chat_id) && count($chat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chat_id when calling chatsControllerClearMessages'
            );
        }


        $resourcePath = '/api/{session}/chats/{chatId}/messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }
        // path params
        if ($chat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chatId' . '}',
                ObjectSerializer::toPathValue($chat_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chatsControllerDeleteChat
     *
     * Deletes the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerDeleteChat'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function chatsControllerDeleteChat($session, $chat_id, string $contentType = self::contentTypes['chatsControllerDeleteChat'][0])
    {
        $this->chatsControllerDeleteChatWithHttpInfo($session, $chat_id, $contentType);
    }

    /**
     * Operation chatsControllerDeleteChatWithHttpInfo
     *
     * Deletes the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerDeleteChat'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerDeleteChatWithHttpInfo($session, $chat_id, string $contentType = self::contentTypes['chatsControllerDeleteChat'][0])
    {
        $request = $this->chatsControllerDeleteChatRequest($session, $chat_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerDeleteChatAsync
     *
     * Deletes the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerDeleteChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerDeleteChatAsync($session, $chat_id, string $contentType = self::contentTypes['chatsControllerDeleteChat'][0])
    {
        return $this->chatsControllerDeleteChatAsyncWithHttpInfo($session, $chat_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerDeleteChatAsyncWithHttpInfo
     *
     * Deletes the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerDeleteChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerDeleteChatAsyncWithHttpInfo($session, $chat_id, string $contentType = self::contentTypes['chatsControllerDeleteChat'][0])
    {
        $returnType = '';
        $request = $this->chatsControllerDeleteChatRequest($session, $chat_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerDeleteChat'
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerDeleteChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerDeleteChatRequest($session, $chat_id, string $contentType = self::contentTypes['chatsControllerDeleteChat'][0])
    {

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerDeleteChat'
            );
        }

        // verify the required parameter 'chat_id' is set
        if ($chat_id === null || (is_array($chat_id) && count($chat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chat_id when calling chatsControllerDeleteChat'
            );
        }


        $resourcePath = '/api/{session}/chats/{chatId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }
        // path params
        if ($chat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chatId' . '}',
                ObjectSerializer::toPathValue($chat_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chatsControllerDeleteMessage
     *
     * Deletes a message from the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id Message ID in format &lt;code&gt;{fromMe}_{chat}_{message_id}[_{participant}]&lt;/code&gt; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerDeleteMessage'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function chatsControllerDeleteMessage($session, $chat_id, $message_id, string $contentType = self::contentTypes['chatsControllerDeleteMessage'][0])
    {
        $this->chatsControllerDeleteMessageWithHttpInfo($session, $chat_id, $message_id, $contentType);
    }

    /**
     * Operation chatsControllerDeleteMessageWithHttpInfo
     *
     * Deletes a message from the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id Message ID in format &lt;code&gt;{fromMe}_{chat}_{message_id}[_{participant}]&lt;/code&gt; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerDeleteMessage'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerDeleteMessageWithHttpInfo($session, $chat_id, $message_id, string $contentType = self::contentTypes['chatsControllerDeleteMessage'][0])
    {
        $request = $this->chatsControllerDeleteMessageRequest($session, $chat_id, $message_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerDeleteMessageAsync
     *
     * Deletes a message from the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id Message ID in format &lt;code&gt;{fromMe}_{chat}_{message_id}[_{participant}]&lt;/code&gt; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerDeleteMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerDeleteMessageAsync($session, $chat_id, $message_id, string $contentType = self::contentTypes['chatsControllerDeleteMessage'][0])
    {
        return $this->chatsControllerDeleteMessageAsyncWithHttpInfo($session, $chat_id, $message_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerDeleteMessageAsyncWithHttpInfo
     *
     * Deletes a message from the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id Message ID in format &lt;code&gt;{fromMe}_{chat}_{message_id}[_{participant}]&lt;/code&gt; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerDeleteMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerDeleteMessageAsyncWithHttpInfo($session, $chat_id, $message_id, string $contentType = self::contentTypes['chatsControllerDeleteMessage'][0])
    {
        $returnType = '';
        $request = $this->chatsControllerDeleteMessageRequest($session, $chat_id, $message_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerDeleteMessage'
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id Message ID in format &lt;code&gt;{fromMe}_{chat}_{message_id}[_{participant}]&lt;/code&gt; (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerDeleteMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerDeleteMessageRequest($session, $chat_id, $message_id, string $contentType = self::contentTypes['chatsControllerDeleteMessage'][0])
    {

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerDeleteMessage'
            );
        }

        // verify the required parameter 'chat_id' is set
        if ($chat_id === null || (is_array($chat_id) && count($chat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chat_id when calling chatsControllerDeleteMessage'
            );
        }

        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_id when calling chatsControllerDeleteMessage'
            );
        }


        $resourcePath = '/api/{session}/chats/{chatId}/messages/{messageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }
        // path params
        if ($chat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chatId' . '}',
                ObjectSerializer::toPathValue($chat_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'messageId' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chatsControllerEditMessage
     *
     * Edits a message in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id Message ID in format &lt;code&gt;{fromMe}_{chat}_{message_id}[_{participant}]&lt;/code&gt; (required)
     * @param  \Vendor\Waha\Generated\Model\EditMessageRequest $edit_message_request edit_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerEditMessage'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function chatsControllerEditMessage($session, $chat_id, $message_id, $edit_message_request, string $contentType = self::contentTypes['chatsControllerEditMessage'][0])
    {
        $this->chatsControllerEditMessageWithHttpInfo($session, $chat_id, $message_id, $edit_message_request, $contentType);
    }

    /**
     * Operation chatsControllerEditMessageWithHttpInfo
     *
     * Edits a message in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id Message ID in format &lt;code&gt;{fromMe}_{chat}_{message_id}[_{participant}]&lt;/code&gt; (required)
     * @param  \Vendor\Waha\Generated\Model\EditMessageRequest $edit_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerEditMessage'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerEditMessageWithHttpInfo($session, $chat_id, $message_id, $edit_message_request, string $contentType = self::contentTypes['chatsControllerEditMessage'][0])
    {
        $request = $this->chatsControllerEditMessageRequest($session, $chat_id, $message_id, $edit_message_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerEditMessageAsync
     *
     * Edits a message in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id Message ID in format &lt;code&gt;{fromMe}_{chat}_{message_id}[_{participant}]&lt;/code&gt; (required)
     * @param  \Vendor\Waha\Generated\Model\EditMessageRequest $edit_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerEditMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerEditMessageAsync($session, $chat_id, $message_id, $edit_message_request, string $contentType = self::contentTypes['chatsControllerEditMessage'][0])
    {
        return $this->chatsControllerEditMessageAsyncWithHttpInfo($session, $chat_id, $message_id, $edit_message_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerEditMessageAsyncWithHttpInfo
     *
     * Edits a message in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id Message ID in format &lt;code&gt;{fromMe}_{chat}_{message_id}[_{participant}]&lt;/code&gt; (required)
     * @param  \Vendor\Waha\Generated\Model\EditMessageRequest $edit_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerEditMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerEditMessageAsyncWithHttpInfo($session, $chat_id, $message_id, $edit_message_request, string $contentType = self::contentTypes['chatsControllerEditMessage'][0])
    {
        $returnType = '';
        $request = $this->chatsControllerEditMessageRequest($session, $chat_id, $message_id, $edit_message_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerEditMessage'
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id Message ID in format &lt;code&gt;{fromMe}_{chat}_{message_id}[_{participant}]&lt;/code&gt; (required)
     * @param  \Vendor\Waha\Generated\Model\EditMessageRequest $edit_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerEditMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerEditMessageRequest($session, $chat_id, $message_id, $edit_message_request, string $contentType = self::contentTypes['chatsControllerEditMessage'][0])
    {

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerEditMessage'
            );
        }

        // verify the required parameter 'chat_id' is set
        if ($chat_id === null || (is_array($chat_id) && count($chat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chat_id when calling chatsControllerEditMessage'
            );
        }

        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_id when calling chatsControllerEditMessage'
            );
        }

        // verify the required parameter 'edit_message_request' is set
        if ($edit_message_request === null || (is_array($edit_message_request) && count($edit_message_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $edit_message_request when calling chatsControllerEditMessage'
            );
        }


        $resourcePath = '/api/{session}/chats/{chatId}/messages/{messageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }
        // path params
        if ($chat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chatId' . '}',
                ObjectSerializer::toPathValue($chat_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'messageId' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($edit_message_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($edit_message_request));
            } else {
                $httpBody = $edit_message_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chatsControllerGetChatMessage
     *
     * Gets message by id
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id message_id (required)
     * @param  bool $download_media Download media for messages (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatMessage'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Vendor\Waha\Generated\Model\WAMessage
     */
    public function chatsControllerGetChatMessage($session, $chat_id, $message_id, $download_media = true, string $contentType = self::contentTypes['chatsControllerGetChatMessage'][0])
    {
        list($response) = $this->chatsControllerGetChatMessageWithHttpInfo($session, $chat_id, $message_id, $download_media, $contentType);
        return $response;
    }

    /**
     * Operation chatsControllerGetChatMessageWithHttpInfo
     *
     * Gets message by id
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id (required)
     * @param  bool $download_media Download media for messages (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatMessage'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Vendor\Waha\Generated\Model\WAMessage, HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerGetChatMessageWithHttpInfo($session, $chat_id, $message_id, $download_media = true, string $contentType = self::contentTypes['chatsControllerGetChatMessage'][0])
    {
        $request = $this->chatsControllerGetChatMessageRequest($session, $chat_id, $message_id, $download_media, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Vendor\Waha\Generated\Model\WAMessage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Vendor\Waha\Generated\Model\WAMessage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Vendor\Waha\Generated\Model\WAMessage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Vendor\Waha\Generated\Model\WAMessage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Vendor\Waha\Generated\Model\WAMessage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerGetChatMessageAsync
     *
     * Gets message by id
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id (required)
     * @param  bool $download_media Download media for messages (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerGetChatMessageAsync($session, $chat_id, $message_id, $download_media = true, string $contentType = self::contentTypes['chatsControllerGetChatMessage'][0])
    {
        return $this->chatsControllerGetChatMessageAsyncWithHttpInfo($session, $chat_id, $message_id, $download_media, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerGetChatMessageAsyncWithHttpInfo
     *
     * Gets message by id
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id (required)
     * @param  bool $download_media Download media for messages (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerGetChatMessageAsyncWithHttpInfo($session, $chat_id, $message_id, $download_media = true, string $contentType = self::contentTypes['chatsControllerGetChatMessage'][0])
    {
        $returnType = '\Vendor\Waha\Generated\Model\WAMessage';
        $request = $this->chatsControllerGetChatMessageRequest($session, $chat_id, $message_id, $download_media, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerGetChatMessage'
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id (required)
     * @param  bool $download_media Download media for messages (optional, default to true)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerGetChatMessageRequest($session, $chat_id, $message_id, $download_media = true, string $contentType = self::contentTypes['chatsControllerGetChatMessage'][0])
    {

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerGetChatMessage'
            );
        }

        // verify the required parameter 'chat_id' is set
        if ($chat_id === null || (is_array($chat_id) && count($chat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chat_id when calling chatsControllerGetChatMessage'
            );
        }

        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_id when calling chatsControllerGetChatMessage'
            );
        }



        $resourcePath = '/api/{session}/chats/{chatId}/messages/{messageId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $download_media,
            'downloadMedia', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }
        // path params
        if ($chat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chatId' . '}',
                ObjectSerializer::toPathValue($chat_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'messageId' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chatsControllerGetChatMessages
     *
     * Gets messages in the chat
     *
     * @param  float $limit limit (required)
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $sort_by Sort by field (optional, default to 'timestamp')
     * @param  string $sort_order Sort order - &lt;b&gt;desc&lt;/b&gt;ending (Z &#x3D;&gt; A, New first) or &lt;b&gt;asc&lt;/b&gt;ending (A &#x3D;&gt; Z, Old first) (optional)
     * @param  bool $download_media Download media for messages (optional, default to true)
     * @param  float $offset offset (optional)
     * @param  float $filter_timestamp_lte Filter messages before this timestamp (inclusive) (optional)
     * @param  float $filter_timestamp_gte Filter messages after this timestamp (inclusive) (optional)
     * @param  bool $filter_from_me From me filter (by default shows all messages) (optional)
     * @param  string $filter_ack Filter messages by acknowledgment status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatMessages'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Vendor\Waha\Generated\Model\WAMessage[]
     */
    public function chatsControllerGetChatMessages($limit, $session, $chat_id, $sort_by = 'timestamp', $sort_order = null, $download_media = true, $offset = null, $filter_timestamp_lte = null, $filter_timestamp_gte = null, $filter_from_me = null, $filter_ack = null, string $contentType = self::contentTypes['chatsControllerGetChatMessages'][0])
    {
        list($response) = $this->chatsControllerGetChatMessagesWithHttpInfo($limit, $session, $chat_id, $sort_by, $sort_order, $download_media, $offset, $filter_timestamp_lte, $filter_timestamp_gte, $filter_from_me, $filter_ack, $contentType);
        return $response;
    }

    /**
     * Operation chatsControllerGetChatMessagesWithHttpInfo
     *
     * Gets messages in the chat
     *
     * @param  float $limit (required)
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $sort_by Sort by field (optional, default to 'timestamp')
     * @param  string $sort_order Sort order - &lt;b&gt;desc&lt;/b&gt;ending (Z &#x3D;&gt; A, New first) or &lt;b&gt;asc&lt;/b&gt;ending (A &#x3D;&gt; Z, Old first) (optional)
     * @param  bool $download_media Download media for messages (optional, default to true)
     * @param  float $offset (optional)
     * @param  float $filter_timestamp_lte Filter messages before this timestamp (inclusive) (optional)
     * @param  float $filter_timestamp_gte Filter messages after this timestamp (inclusive) (optional)
     * @param  bool $filter_from_me From me filter (by default shows all messages) (optional)
     * @param  string $filter_ack Filter messages by acknowledgment status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatMessages'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Vendor\Waha\Generated\Model\WAMessage[], HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerGetChatMessagesWithHttpInfo($limit, $session, $chat_id, $sort_by = 'timestamp', $sort_order = null, $download_media = true, $offset = null, $filter_timestamp_lte = null, $filter_timestamp_gte = null, $filter_from_me = null, $filter_ack = null, string $contentType = self::contentTypes['chatsControllerGetChatMessages'][0])
    {
        $request = $this->chatsControllerGetChatMessagesRequest($limit, $session, $chat_id, $sort_by, $sort_order, $download_media, $offset, $filter_timestamp_lte, $filter_timestamp_gte, $filter_from_me, $filter_ack, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Vendor\Waha\Generated\Model\WAMessage[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Vendor\Waha\Generated\Model\WAMessage[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Vendor\Waha\Generated\Model\WAMessage[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Vendor\Waha\Generated\Model\WAMessage[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Vendor\Waha\Generated\Model\WAMessage[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerGetChatMessagesAsync
     *
     * Gets messages in the chat
     *
     * @param  float $limit (required)
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $sort_by Sort by field (optional, default to 'timestamp')
     * @param  string $sort_order Sort order - &lt;b&gt;desc&lt;/b&gt;ending (Z &#x3D;&gt; A, New first) or &lt;b&gt;asc&lt;/b&gt;ending (A &#x3D;&gt; Z, Old first) (optional)
     * @param  bool $download_media Download media for messages (optional, default to true)
     * @param  float $offset (optional)
     * @param  float $filter_timestamp_lte Filter messages before this timestamp (inclusive) (optional)
     * @param  float $filter_timestamp_gte Filter messages after this timestamp (inclusive) (optional)
     * @param  bool $filter_from_me From me filter (by default shows all messages) (optional)
     * @param  string $filter_ack Filter messages by acknowledgment status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerGetChatMessagesAsync($limit, $session, $chat_id, $sort_by = 'timestamp', $sort_order = null, $download_media = true, $offset = null, $filter_timestamp_lte = null, $filter_timestamp_gte = null, $filter_from_me = null, $filter_ack = null, string $contentType = self::contentTypes['chatsControllerGetChatMessages'][0])
    {
        return $this->chatsControllerGetChatMessagesAsyncWithHttpInfo($limit, $session, $chat_id, $sort_by, $sort_order, $download_media, $offset, $filter_timestamp_lte, $filter_timestamp_gte, $filter_from_me, $filter_ack, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerGetChatMessagesAsyncWithHttpInfo
     *
     * Gets messages in the chat
     *
     * @param  float $limit (required)
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $sort_by Sort by field (optional, default to 'timestamp')
     * @param  string $sort_order Sort order - &lt;b&gt;desc&lt;/b&gt;ending (Z &#x3D;&gt; A, New first) or &lt;b&gt;asc&lt;/b&gt;ending (A &#x3D;&gt; Z, Old first) (optional)
     * @param  bool $download_media Download media for messages (optional, default to true)
     * @param  float $offset (optional)
     * @param  float $filter_timestamp_lte Filter messages before this timestamp (inclusive) (optional)
     * @param  float $filter_timestamp_gte Filter messages after this timestamp (inclusive) (optional)
     * @param  bool $filter_from_me From me filter (by default shows all messages) (optional)
     * @param  string $filter_ack Filter messages by acknowledgment status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerGetChatMessagesAsyncWithHttpInfo($limit, $session, $chat_id, $sort_by = 'timestamp', $sort_order = null, $download_media = true, $offset = null, $filter_timestamp_lte = null, $filter_timestamp_gte = null, $filter_from_me = null, $filter_ack = null, string $contentType = self::contentTypes['chatsControllerGetChatMessages'][0])
    {
        $returnType = '\Vendor\Waha\Generated\Model\WAMessage[]';
        $request = $this->chatsControllerGetChatMessagesRequest($limit, $session, $chat_id, $sort_by, $sort_order, $download_media, $offset, $filter_timestamp_lte, $filter_timestamp_gte, $filter_from_me, $filter_ack, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerGetChatMessages'
     *
     * @param  float $limit (required)
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $sort_by Sort by field (optional, default to 'timestamp')
     * @param  string $sort_order Sort order - &lt;b&gt;desc&lt;/b&gt;ending (Z &#x3D;&gt; A, New first) or &lt;b&gt;asc&lt;/b&gt;ending (A &#x3D;&gt; Z, Old first) (optional)
     * @param  bool $download_media Download media for messages (optional, default to true)
     * @param  float $offset (optional)
     * @param  float $filter_timestamp_lte Filter messages before this timestamp (inclusive) (optional)
     * @param  float $filter_timestamp_gte Filter messages after this timestamp (inclusive) (optional)
     * @param  bool $filter_from_me From me filter (by default shows all messages) (optional)
     * @param  string $filter_ack Filter messages by acknowledgment status (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerGetChatMessagesRequest($limit, $session, $chat_id, $sort_by = 'timestamp', $sort_order = null, $download_media = true, $offset = null, $filter_timestamp_lte = null, $filter_timestamp_gte = null, $filter_from_me = null, $filter_ack = null, string $contentType = self::contentTypes['chatsControllerGetChatMessages'][0])
    {

        // verify the required parameter 'limit' is set
        if ($limit === null || (is_array($limit) && count($limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $limit when calling chatsControllerGetChatMessages'
            );
        }

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerGetChatMessages'
            );
        }

        // verify the required parameter 'chat_id' is set
        if ($chat_id === null || (is_array($chat_id) && count($chat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chat_id when calling chatsControllerGetChatMessages'
            );
        }










        $resourcePath = '/api/{session}/chats/{chatId}/messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $download_media,
            'downloadMedia', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_timestamp_lte,
            'filter.timestamp.lte', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_timestamp_gte,
            'filter.timestamp.gte', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_from_me,
            'filter.fromMe', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_ack,
            'filter.ack', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }
        // path params
        if ($chat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chatId' . '}',
                ObjectSerializer::toPathValue($chat_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chatsControllerGetChatPicture
     *
     * Gets chat picture
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id chat_id (required)
     * @param  bool $refresh Refresh the picture from the server (24h cache by default). Do not refresh if not needed, you can get rate limit error (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatPicture'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Vendor\Waha\Generated\Model\ChatPictureResponse
     */
    public function chatsControllerGetChatPicture($session, $chat_id, $refresh = false, string $contentType = self::contentTypes['chatsControllerGetChatPicture'][0])
    {
        list($response) = $this->chatsControllerGetChatPictureWithHttpInfo($session, $chat_id, $refresh, $contentType);
        return $response;
    }

    /**
     * Operation chatsControllerGetChatPictureWithHttpInfo
     *
     * Gets chat picture
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id (required)
     * @param  bool $refresh Refresh the picture from the server (24h cache by default). Do not refresh if not needed, you can get rate limit error (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatPicture'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Vendor\Waha\Generated\Model\ChatPictureResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerGetChatPictureWithHttpInfo($session, $chat_id, $refresh = false, string $contentType = self::contentTypes['chatsControllerGetChatPicture'][0])
    {
        $request = $this->chatsControllerGetChatPictureRequest($session, $chat_id, $refresh, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Vendor\Waha\Generated\Model\ChatPictureResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Vendor\Waha\Generated\Model\ChatPictureResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Vendor\Waha\Generated\Model\ChatPictureResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Vendor\Waha\Generated\Model\ChatPictureResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Vendor\Waha\Generated\Model\ChatPictureResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerGetChatPictureAsync
     *
     * Gets chat picture
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id (required)
     * @param  bool $refresh Refresh the picture from the server (24h cache by default). Do not refresh if not needed, you can get rate limit error (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatPicture'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerGetChatPictureAsync($session, $chat_id, $refresh = false, string $contentType = self::contentTypes['chatsControllerGetChatPicture'][0])
    {
        return $this->chatsControllerGetChatPictureAsyncWithHttpInfo($session, $chat_id, $refresh, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerGetChatPictureAsyncWithHttpInfo
     *
     * Gets chat picture
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id (required)
     * @param  bool $refresh Refresh the picture from the server (24h cache by default). Do not refresh if not needed, you can get rate limit error (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatPicture'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerGetChatPictureAsyncWithHttpInfo($session, $chat_id, $refresh = false, string $contentType = self::contentTypes['chatsControllerGetChatPicture'][0])
    {
        $returnType = '\Vendor\Waha\Generated\Model\ChatPictureResponse';
        $request = $this->chatsControllerGetChatPictureRequest($session, $chat_id, $refresh, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerGetChatPicture'
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id (required)
     * @param  bool $refresh Refresh the picture from the server (24h cache by default). Do not refresh if not needed, you can get rate limit error (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatPicture'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerGetChatPictureRequest($session, $chat_id, $refresh = false, string $contentType = self::contentTypes['chatsControllerGetChatPicture'][0])
    {

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerGetChatPicture'
            );
        }

        // verify the required parameter 'chat_id' is set
        if ($chat_id === null || (is_array($chat_id) && count($chat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chat_id when calling chatsControllerGetChatPicture'
            );
        }



        $resourcePath = '/api/{session}/chats/{chatId}/picture';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $refresh,
            'refresh', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }
        // path params
        if ($chat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chatId' . '}',
                ObjectSerializer::toPathValue($chat_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chatsControllerGetChats
     *
     * Get chats
     *
     * @param  mixed $session Session name (required)
     * @param  string $sort_by Sort by field (optional)
     * @param  string $sort_order Sort order - &lt;b&gt;desc&lt;/b&gt;ending (Z &#x3D;&gt; A, New first) or &lt;b&gt;asc&lt;/b&gt;ending (A &#x3D;&gt; Z, Old first) (optional)
     * @param  float $limit limit (optional)
     * @param  float $offset offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChats'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function chatsControllerGetChats($session, $sort_by = null, $sort_order = null, $limit = null, $offset = null, string $contentType = self::contentTypes['chatsControllerGetChats'][0])
    {
        $this->chatsControllerGetChatsWithHttpInfo($session, $sort_by, $sort_order, $limit, $offset, $contentType);
    }

    /**
     * Operation chatsControllerGetChatsWithHttpInfo
     *
     * Get chats
     *
     * @param  mixed $session Session name (required)
     * @param  string $sort_by Sort by field (optional)
     * @param  string $sort_order Sort order - &lt;b&gt;desc&lt;/b&gt;ending (Z &#x3D;&gt; A, New first) or &lt;b&gt;asc&lt;/b&gt;ending (A &#x3D;&gt; Z, Old first) (optional)
     * @param  float $limit (optional)
     * @param  float $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChats'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerGetChatsWithHttpInfo($session, $sort_by = null, $sort_order = null, $limit = null, $offset = null, string $contentType = self::contentTypes['chatsControllerGetChats'][0])
    {
        $request = $this->chatsControllerGetChatsRequest($session, $sort_by, $sort_order, $limit, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerGetChatsAsync
     *
     * Get chats
     *
     * @param  mixed $session Session name (required)
     * @param  string $sort_by Sort by field (optional)
     * @param  string $sort_order Sort order - &lt;b&gt;desc&lt;/b&gt;ending (Z &#x3D;&gt; A, New first) or &lt;b&gt;asc&lt;/b&gt;ending (A &#x3D;&gt; Z, Old first) (optional)
     * @param  float $limit (optional)
     * @param  float $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerGetChatsAsync($session, $sort_by = null, $sort_order = null, $limit = null, $offset = null, string $contentType = self::contentTypes['chatsControllerGetChats'][0])
    {
        return $this->chatsControllerGetChatsAsyncWithHttpInfo($session, $sort_by, $sort_order, $limit, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerGetChatsAsyncWithHttpInfo
     *
     * Get chats
     *
     * @param  mixed $session Session name (required)
     * @param  string $sort_by Sort by field (optional)
     * @param  string $sort_order Sort order - &lt;b&gt;desc&lt;/b&gt;ending (Z &#x3D;&gt; A, New first) or &lt;b&gt;asc&lt;/b&gt;ending (A &#x3D;&gt; Z, Old first) (optional)
     * @param  float $limit (optional)
     * @param  float $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerGetChatsAsyncWithHttpInfo($session, $sort_by = null, $sort_order = null, $limit = null, $offset = null, string $contentType = self::contentTypes['chatsControllerGetChats'][0])
    {
        $returnType = '';
        $request = $this->chatsControllerGetChatsRequest($session, $sort_by, $sort_order, $limit, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerGetChats'
     *
     * @param  mixed $session Session name (required)
     * @param  string $sort_by Sort by field (optional)
     * @param  string $sort_order Sort order - &lt;b&gt;desc&lt;/b&gt;ending (Z &#x3D;&gt; A, New first) or &lt;b&gt;asc&lt;/b&gt;ending (A &#x3D;&gt; Z, Old first) (optional)
     * @param  float $limit (optional)
     * @param  float $offset (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerGetChatsRequest($session, $sort_by = null, $sort_order = null, $limit = null, $offset = null, string $contentType = self::contentTypes['chatsControllerGetChats'][0])
    {

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerGetChats'
            );
        }






        $resourcePath = '/api/{session}/chats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chatsControllerGetChatsOverview
     *
     * Get chats overview. Includes all necessary things to build UI \&quot;your chats overview\&quot; page - chat id, name, picture, last message. Sorting by last message timestamp
     *
     * @param  mixed $session Session name (required)
     * @param  float $limit limit (optional, default to 20)
     * @param  float $offset offset (optional)
     * @param  string[] $ids Filter by chat ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatsOverview'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Vendor\Waha\Generated\Model\ChatSummary[]
     */
    public function chatsControllerGetChatsOverview($session, $limit = 20, $offset = null, $ids = null, string $contentType = self::contentTypes['chatsControllerGetChatsOverview'][0])
    {
        list($response) = $this->chatsControllerGetChatsOverviewWithHttpInfo($session, $limit, $offset, $ids, $contentType);
        return $response;
    }

    /**
     * Operation chatsControllerGetChatsOverviewWithHttpInfo
     *
     * Get chats overview. Includes all necessary things to build UI \&quot;your chats overview\&quot; page - chat id, name, picture, last message. Sorting by last message timestamp
     *
     * @param  mixed $session Session name (required)
     * @param  float $limit (optional, default to 20)
     * @param  float $offset (optional)
     * @param  string[] $ids Filter by chat ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatsOverview'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Vendor\Waha\Generated\Model\ChatSummary[], HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerGetChatsOverviewWithHttpInfo($session, $limit = 20, $offset = null, $ids = null, string $contentType = self::contentTypes['chatsControllerGetChatsOverview'][0])
    {
        $request = $this->chatsControllerGetChatsOverviewRequest($session, $limit, $offset, $ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Vendor\Waha\Generated\Model\ChatSummary[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Vendor\Waha\Generated\Model\ChatSummary[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Vendor\Waha\Generated\Model\ChatSummary[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Vendor\Waha\Generated\Model\ChatSummary[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Vendor\Waha\Generated\Model\ChatSummary[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerGetChatsOverviewAsync
     *
     * Get chats overview. Includes all necessary things to build UI \&quot;your chats overview\&quot; page - chat id, name, picture, last message. Sorting by last message timestamp
     *
     * @param  mixed $session Session name (required)
     * @param  float $limit (optional, default to 20)
     * @param  float $offset (optional)
     * @param  string[] $ids Filter by chat ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerGetChatsOverviewAsync($session, $limit = 20, $offset = null, $ids = null, string $contentType = self::contentTypes['chatsControllerGetChatsOverview'][0])
    {
        return $this->chatsControllerGetChatsOverviewAsyncWithHttpInfo($session, $limit, $offset, $ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerGetChatsOverviewAsyncWithHttpInfo
     *
     * Get chats overview. Includes all necessary things to build UI \&quot;your chats overview\&quot; page - chat id, name, picture, last message. Sorting by last message timestamp
     *
     * @param  mixed $session Session name (required)
     * @param  float $limit (optional, default to 20)
     * @param  float $offset (optional)
     * @param  string[] $ids Filter by chat ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerGetChatsOverviewAsyncWithHttpInfo($session, $limit = 20, $offset = null, $ids = null, string $contentType = self::contentTypes['chatsControllerGetChatsOverview'][0])
    {
        $returnType = '\Vendor\Waha\Generated\Model\ChatSummary[]';
        $request = $this->chatsControllerGetChatsOverviewRequest($session, $limit, $offset, $ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerGetChatsOverview'
     *
     * @param  mixed $session Session name (required)
     * @param  float $limit (optional, default to 20)
     * @param  float $offset (optional)
     * @param  string[] $ids Filter by chat ids (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerGetChatsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerGetChatsOverviewRequest($session, $limit = 20, $offset = null, $ids = null, string $contentType = self::contentTypes['chatsControllerGetChatsOverview'][0])
    {

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerGetChatsOverview'
            );
        }





        $resourcePath = '/api/{session}/chats/overview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ids,
            'ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chatsControllerPinMessage
     *
     * Pins a message in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id message_id (required)
     * @param  \Vendor\Waha\Generated\Model\PinMessageRequest $pin_message_request pin_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerPinMessage'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function chatsControllerPinMessage($session, $chat_id, $message_id, $pin_message_request, string $contentType = self::contentTypes['chatsControllerPinMessage'][0])
    {
        $this->chatsControllerPinMessageWithHttpInfo($session, $chat_id, $message_id, $pin_message_request, $contentType);
    }

    /**
     * Operation chatsControllerPinMessageWithHttpInfo
     *
     * Pins a message in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id (required)
     * @param  \Vendor\Waha\Generated\Model\PinMessageRequest $pin_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerPinMessage'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerPinMessageWithHttpInfo($session, $chat_id, $message_id, $pin_message_request, string $contentType = self::contentTypes['chatsControllerPinMessage'][0])
    {
        $request = $this->chatsControllerPinMessageRequest($session, $chat_id, $message_id, $pin_message_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerPinMessageAsync
     *
     * Pins a message in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id (required)
     * @param  \Vendor\Waha\Generated\Model\PinMessageRequest $pin_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerPinMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerPinMessageAsync($session, $chat_id, $message_id, $pin_message_request, string $contentType = self::contentTypes['chatsControllerPinMessage'][0])
    {
        return $this->chatsControllerPinMessageAsyncWithHttpInfo($session, $chat_id, $message_id, $pin_message_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerPinMessageAsyncWithHttpInfo
     *
     * Pins a message in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id (required)
     * @param  \Vendor\Waha\Generated\Model\PinMessageRequest $pin_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerPinMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerPinMessageAsyncWithHttpInfo($session, $chat_id, $message_id, $pin_message_request, string $contentType = self::contentTypes['chatsControllerPinMessage'][0])
    {
        $returnType = '';
        $request = $this->chatsControllerPinMessageRequest($session, $chat_id, $message_id, $pin_message_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerPinMessage'
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id (required)
     * @param  \Vendor\Waha\Generated\Model\PinMessageRequest $pin_message_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerPinMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerPinMessageRequest($session, $chat_id, $message_id, $pin_message_request, string $contentType = self::contentTypes['chatsControllerPinMessage'][0])
    {

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerPinMessage'
            );
        }

        // verify the required parameter 'chat_id' is set
        if ($chat_id === null || (is_array($chat_id) && count($chat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chat_id when calling chatsControllerPinMessage'
            );
        }

        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_id when calling chatsControllerPinMessage'
            );
        }

        // verify the required parameter 'pin_message_request' is set
        if ($pin_message_request === null || (is_array($pin_message_request) && count($pin_message_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pin_message_request when calling chatsControllerPinMessage'
            );
        }


        $resourcePath = '/api/{session}/chats/{chatId}/messages/{messageId}/pin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }
        // path params
        if ($chat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chatId' . '}',
                ObjectSerializer::toPathValue($chat_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'messageId' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($pin_message_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($pin_message_request));
            } else {
                $httpBody = $pin_message_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chatsControllerPostChatsOverview
     *
     * Get chats overview. Use POST if you have too many \&quot;ids\&quot; params - GET can limit it
     *
     * @param  mixed $session Session name (required)
     * @param  \Vendor\Waha\Generated\Model\OverviewBodyRequest $overview_body_request overview_body_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerPostChatsOverview'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Vendor\Waha\Generated\Model\ChatSummary[]
     */
    public function chatsControllerPostChatsOverview($session, $overview_body_request, string $contentType = self::contentTypes['chatsControllerPostChatsOverview'][0])
    {
        list($response) = $this->chatsControllerPostChatsOverviewWithHttpInfo($session, $overview_body_request, $contentType);
        return $response;
    }

    /**
     * Operation chatsControllerPostChatsOverviewWithHttpInfo
     *
     * Get chats overview. Use POST if you have too many \&quot;ids\&quot; params - GET can limit it
     *
     * @param  mixed $session Session name (required)
     * @param  \Vendor\Waha\Generated\Model\OverviewBodyRequest $overview_body_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerPostChatsOverview'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Vendor\Waha\Generated\Model\ChatSummary[], HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerPostChatsOverviewWithHttpInfo($session, $overview_body_request, string $contentType = self::contentTypes['chatsControllerPostChatsOverview'][0])
    {
        $request = $this->chatsControllerPostChatsOverviewRequest($session, $overview_body_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\Vendor\Waha\Generated\Model\ChatSummary[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Vendor\Waha\Generated\Model\ChatSummary[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Vendor\Waha\Generated\Model\ChatSummary[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Vendor\Waha\Generated\Model\ChatSummary[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Vendor\Waha\Generated\Model\ChatSummary[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerPostChatsOverviewAsync
     *
     * Get chats overview. Use POST if you have too many \&quot;ids\&quot; params - GET can limit it
     *
     * @param  mixed $session Session name (required)
     * @param  \Vendor\Waha\Generated\Model\OverviewBodyRequest $overview_body_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerPostChatsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerPostChatsOverviewAsync($session, $overview_body_request, string $contentType = self::contentTypes['chatsControllerPostChatsOverview'][0])
    {
        return $this->chatsControllerPostChatsOverviewAsyncWithHttpInfo($session, $overview_body_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerPostChatsOverviewAsyncWithHttpInfo
     *
     * Get chats overview. Use POST if you have too many \&quot;ids\&quot; params - GET can limit it
     *
     * @param  mixed $session Session name (required)
     * @param  \Vendor\Waha\Generated\Model\OverviewBodyRequest $overview_body_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerPostChatsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerPostChatsOverviewAsyncWithHttpInfo($session, $overview_body_request, string $contentType = self::contentTypes['chatsControllerPostChatsOverview'][0])
    {
        $returnType = '\Vendor\Waha\Generated\Model\ChatSummary[]';
        $request = $this->chatsControllerPostChatsOverviewRequest($session, $overview_body_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerPostChatsOverview'
     *
     * @param  mixed $session Session name (required)
     * @param  \Vendor\Waha\Generated\Model\OverviewBodyRequest $overview_body_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerPostChatsOverview'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerPostChatsOverviewRequest($session, $overview_body_request, string $contentType = self::contentTypes['chatsControllerPostChatsOverview'][0])
    {

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerPostChatsOverview'
            );
        }

        // verify the required parameter 'overview_body_request' is set
        if ($overview_body_request === null || (is_array($overview_body_request) && count($overview_body_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $overview_body_request when calling chatsControllerPostChatsOverview'
            );
        }


        $resourcePath = '/api/{session}/chats/overview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($overview_body_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($overview_body_request));
            } else {
                $httpBody = $overview_body_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chatsControllerReadChatMessages
     *
     * Read unread messages in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  float $messages How much messages to read (latest first) (optional)
     * @param  float $days How much days to read (latest first) (optional, default to 7)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerReadChatMessages'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Vendor\Waha\Generated\Model\ReadChatMessagesResponse
     */
    public function chatsControllerReadChatMessages($session, $chat_id, $messages = null, $days = 7, string $contentType = self::contentTypes['chatsControllerReadChatMessages'][0])
    {
        list($response) = $this->chatsControllerReadChatMessagesWithHttpInfo($session, $chat_id, $messages, $days, $contentType);
        return $response;
    }

    /**
     * Operation chatsControllerReadChatMessagesWithHttpInfo
     *
     * Read unread messages in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  float $messages How much messages to read (latest first) (optional)
     * @param  float $days How much days to read (latest first) (optional, default to 7)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerReadChatMessages'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Vendor\Waha\Generated\Model\ReadChatMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerReadChatMessagesWithHttpInfo($session, $chat_id, $messages = null, $days = 7, string $contentType = self::contentTypes['chatsControllerReadChatMessages'][0])
    {
        $request = $this->chatsControllerReadChatMessagesRequest($session, $chat_id, $messages, $days, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\Vendor\Waha\Generated\Model\ReadChatMessagesResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Vendor\Waha\Generated\Model\ReadChatMessagesResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Vendor\Waha\Generated\Model\ReadChatMessagesResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Vendor\Waha\Generated\Model\ReadChatMessagesResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Vendor\Waha\Generated\Model\ReadChatMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerReadChatMessagesAsync
     *
     * Read unread messages in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  float $messages How much messages to read (latest first) (optional)
     * @param  float $days How much days to read (latest first) (optional, default to 7)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerReadChatMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerReadChatMessagesAsync($session, $chat_id, $messages = null, $days = 7, string $contentType = self::contentTypes['chatsControllerReadChatMessages'][0])
    {
        return $this->chatsControllerReadChatMessagesAsyncWithHttpInfo($session, $chat_id, $messages, $days, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerReadChatMessagesAsyncWithHttpInfo
     *
     * Read unread messages in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  float $messages How much messages to read (latest first) (optional)
     * @param  float $days How much days to read (latest first) (optional, default to 7)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerReadChatMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerReadChatMessagesAsyncWithHttpInfo($session, $chat_id, $messages = null, $days = 7, string $contentType = self::contentTypes['chatsControllerReadChatMessages'][0])
    {
        $returnType = '\Vendor\Waha\Generated\Model\ReadChatMessagesResponse';
        $request = $this->chatsControllerReadChatMessagesRequest($session, $chat_id, $messages, $days, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerReadChatMessages'
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  float $messages How much messages to read (latest first) (optional)
     * @param  float $days How much days to read (latest first) (optional, default to 7)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerReadChatMessages'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerReadChatMessagesRequest($session, $chat_id, $messages = null, $days = 7, string $contentType = self::contentTypes['chatsControllerReadChatMessages'][0])
    {

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerReadChatMessages'
            );
        }

        // verify the required parameter 'chat_id' is set
        if ($chat_id === null || (is_array($chat_id) && count($chat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chat_id when calling chatsControllerReadChatMessages'
            );
        }




        $resourcePath = '/api/{session}/chats/{chatId}/messages/read';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $messages,
            'messages', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $days,
            'days', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }
        // path params
        if ($chat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chatId' . '}',
                ObjectSerializer::toPathValue($chat_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chatsControllerUnarchiveChat
     *
     * Unarchive the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerUnarchiveChat'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function chatsControllerUnarchiveChat($session, $chat_id, string $contentType = self::contentTypes['chatsControllerUnarchiveChat'][0])
    {
        list($response) = $this->chatsControllerUnarchiveChatWithHttpInfo($session, $chat_id, $contentType);
        return $response;
    }

    /**
     * Operation chatsControllerUnarchiveChatWithHttpInfo
     *
     * Unarchive the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerUnarchiveChat'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerUnarchiveChatWithHttpInfo($session, $chat_id, string $contentType = self::contentTypes['chatsControllerUnarchiveChat'][0])
    {
        $request = $this->chatsControllerUnarchiveChatRequest($session, $chat_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerUnarchiveChatAsync
     *
     * Unarchive the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerUnarchiveChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerUnarchiveChatAsync($session, $chat_id, string $contentType = self::contentTypes['chatsControllerUnarchiveChat'][0])
    {
        return $this->chatsControllerUnarchiveChatAsyncWithHttpInfo($session, $chat_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerUnarchiveChatAsyncWithHttpInfo
     *
     * Unarchive the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerUnarchiveChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerUnarchiveChatAsyncWithHttpInfo($session, $chat_id, string $contentType = self::contentTypes['chatsControllerUnarchiveChat'][0])
    {
        $returnType = 'object';
        $request = $this->chatsControllerUnarchiveChatRequest($session, $chat_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerUnarchiveChat'
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerUnarchiveChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerUnarchiveChatRequest($session, $chat_id, string $contentType = self::contentTypes['chatsControllerUnarchiveChat'][0])
    {

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerUnarchiveChat'
            );
        }

        // verify the required parameter 'chat_id' is set
        if ($chat_id === null || (is_array($chat_id) && count($chat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chat_id when calling chatsControllerUnarchiveChat'
            );
        }


        $resourcePath = '/api/{session}/chats/{chatId}/unarchive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }
        // path params
        if ($chat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chatId' . '}',
                ObjectSerializer::toPathValue($chat_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chatsControllerUnpinMessage
     *
     * Unpins a message in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerUnpinMessage'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function chatsControllerUnpinMessage($session, $chat_id, $message_id, string $contentType = self::contentTypes['chatsControllerUnpinMessage'][0])
    {
        $this->chatsControllerUnpinMessageWithHttpInfo($session, $chat_id, $message_id, $contentType);
    }

    /**
     * Operation chatsControllerUnpinMessageWithHttpInfo
     *
     * Unpins a message in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerUnpinMessage'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerUnpinMessageWithHttpInfo($session, $chat_id, $message_id, string $contentType = self::contentTypes['chatsControllerUnpinMessage'][0])
    {
        $request = $this->chatsControllerUnpinMessageRequest($session, $chat_id, $message_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerUnpinMessageAsync
     *
     * Unpins a message in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerUnpinMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerUnpinMessageAsync($session, $chat_id, $message_id, string $contentType = self::contentTypes['chatsControllerUnpinMessage'][0])
    {
        return $this->chatsControllerUnpinMessageAsyncWithHttpInfo($session, $chat_id, $message_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerUnpinMessageAsyncWithHttpInfo
     *
     * Unpins a message in the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerUnpinMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerUnpinMessageAsyncWithHttpInfo($session, $chat_id, $message_id, string $contentType = self::contentTypes['chatsControllerUnpinMessage'][0])
    {
        $returnType = '';
        $request = $this->chatsControllerUnpinMessageRequest($session, $chat_id, $message_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerUnpinMessage'
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $message_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerUnpinMessage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerUnpinMessageRequest($session, $chat_id, $message_id, string $contentType = self::contentTypes['chatsControllerUnpinMessage'][0])
    {

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerUnpinMessage'
            );
        }

        // verify the required parameter 'chat_id' is set
        if ($chat_id === null || (is_array($chat_id) && count($chat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chat_id when calling chatsControllerUnpinMessage'
            );
        }

        // verify the required parameter 'message_id' is set
        if ($message_id === null || (is_array($message_id) && count($message_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $message_id when calling chatsControllerUnpinMessage'
            );
        }


        $resourcePath = '/api/{session}/chats/{chatId}/messages/{messageId}/unpin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }
        // path params
        if ($chat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chatId' . '}',
                ObjectSerializer::toPathValue($chat_id),
                $resourcePath
            );
        }
        // path params
        if ($message_id !== null) {
            $resourcePath = str_replace(
                '{' . 'messageId' . '}',
                ObjectSerializer::toPathValue($message_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chatsControllerUnreadChat
     *
     * Unread the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerUnreadChat'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function chatsControllerUnreadChat($session, $chat_id, string $contentType = self::contentTypes['chatsControllerUnreadChat'][0])
    {
        list($response) = $this->chatsControllerUnreadChatWithHttpInfo($session, $chat_id, $contentType);
        return $response;
    }

    /**
     * Operation chatsControllerUnreadChatWithHttpInfo
     *
     * Unread the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerUnreadChat'] to see the possible values for this operation
     *
     * @throws \Vendor\Waha\Generated\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function chatsControllerUnreadChatWithHttpInfo($session, $chat_id, string $contentType = self::contentTypes['chatsControllerUnreadChat'][0])
    {
        $request = $this->chatsControllerUnreadChatRequest($session, $chat_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chatsControllerUnreadChatAsync
     *
     * Unread the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerUnreadChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerUnreadChatAsync($session, $chat_id, string $contentType = self::contentTypes['chatsControllerUnreadChat'][0])
    {
        return $this->chatsControllerUnreadChatAsyncWithHttpInfo($session, $chat_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chatsControllerUnreadChatAsyncWithHttpInfo
     *
     * Unread the chat
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerUnreadChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chatsControllerUnreadChatAsyncWithHttpInfo($session, $chat_id, string $contentType = self::contentTypes['chatsControllerUnreadChat'][0])
    {
        $returnType = 'object';
        $request = $this->chatsControllerUnreadChatRequest($session, $chat_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chatsControllerUnreadChat'
     *
     * @param  mixed $session Session name (required)
     * @param  string $chat_id Chat ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chatsControllerUnreadChat'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chatsControllerUnreadChatRequest($session, $chat_id, string $contentType = self::contentTypes['chatsControllerUnreadChat'][0])
    {

        // verify the required parameter 'session' is set
        if ($session === null || (is_array($session) && count($session) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session when calling chatsControllerUnreadChat'
            );
        }

        // verify the required parameter 'chat_id' is set
        if ($chat_id === null || (is_array($chat_id) && count($chat_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chat_id when calling chatsControllerUnreadChat'
            );
        }


        $resourcePath = '/api/{session}/chats/{chatId}/unread';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($session !== null) {
            $resourcePath = str_replace(
                '{' . 'session' . '}',
                ObjectSerializer::toPathValue($session),
                $resourcePath
            );
        }
        // path params
        if ($chat_id !== null) {
            $resourcePath = str_replace(
                '{' . 'chatId' . '}',
                ObjectSerializer::toPathValue($chat_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Api-Key');
        if ($apiKey !== null) {
            $headers['X-Api-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
